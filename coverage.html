
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>familytree: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/GeovaneCavalcante/tree-genealogical/familytree/service.go (100.0%)</option>
				
				<option value="file1">github.com/GeovaneCavalcante/tree-genealogical/internal/http/gin/familytree.go (100.0%)</option>
				
				<option value="file2">github.com/GeovaneCavalcante/tree-genealogical/internal/http/gin/handler.go (100.0%)</option>
				
				<option value="file3">github.com/GeovaneCavalcante/tree-genealogical/internal/http/gin/person.go (100.0%)</option>
				
				<option value="file4">github.com/GeovaneCavalcante/tree-genealogical/internal/http/gin/relationship.go (100.0%)</option>
				
				<option value="file5">github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter/familytree.go (100.0%)</option>
				
				<option value="file6">github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter/person.go (100.0%)</option>
				
				<option value="file7">github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter/relationship.go (100.0%)</option>
				
				<option value="file8">github.com/GeovaneCavalcante/tree-genealogical/person/service.go (100.0%)</option>
				
				<option value="file9">github.com/GeovaneCavalcante/tree-genealogical/pkg/genealogy/genealogy.go (100.0%)</option>
				
				<option value="file10">github.com/GeovaneCavalcante/tree-genealogical/relationship/service.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package familytree

import (
        "context"
        "fmt"
        "strings"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/GeovaneCavalcante/tree-genealogical/person"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
        "github.com/GeovaneCavalcante/tree-genealogical/relationship"
)

type Service struct {
        Genealogy        GenealogyInterface
        PersonRepo       person.Repository
        RelationshipRepo relationship.Repository
}

func NewService(genealogy GenealogyInterface, personRepo person.Repository, relationshipRepo relationship.Repository) *Service <span class="cov8" title="1">{
        return &amp;Service{
                Genealogy:        genealogy,
                PersonRepo:       personRepo,
                RelationshipRepo: relationshipRepo,
        }
}</span>

func (s *Service) GetAllFamilyMembers(ctx context.Context, personName string) ([]*entity.Relative, error) <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] GetAllFamilyMembers started for personName: %s", personName))

        person, err := s.PersonRepo.GetByName(ctx, personName)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] GetAllFamilyMembers error for personName: %s", personName), err)
                return nil, fmt.Errorf("get person error: %w", err)
        }</span>

        <span class="cov8" title="1">persons, err := s.PersonRepo.ListWithRelationships(ctx, nil)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] GetAllFamilyMembers error for personName: %s", personName), err)
                return nil, fmt.Errorf("get person error: %w", err)
        }</span>

        <span class="cov8" title="1">relatives := s.Genealogy.BuildFamilyTree(ctx, person, persons, 0)

        logger.Info(fmt.Sprintf("[Service] GetAllFamilyMembers finished for personName: %s", personName))
        return relatives, nil</span>
}

func (s *Service) DetermineRelationship(ctx context.Context, firstPersonName, secondPersonName string) (relationship string, err error) <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] DetermineRelationship started for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))

        firstPerson, err := s.PersonRepo.GetByName(ctx, firstPersonName)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] DetermineRelationship error for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName), err)
                return "", fmt.Errorf("get person error: %w", err)
        }</span>

        <span class="cov8" title="1">persons, err := s.PersonRepo.ListWithRelationships(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] DetermineRelationship error for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName), err)
                return "", fmt.Errorf("get person error: %w", err)
        }</span>
        <span class="cov8" title="1">relatives := s.Genealogy.BuildFamilyTree(ctx, firstPerson, persons, 1)

        if len(relatives) == 0 </span><span class="cov8" title="1">{
                logger.Info(fmt.Sprintf("[Service] DetermineRelationship finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))
                return "unrelated", nil
        }</span>

        <span class="cov8" title="1">for _, relative := range relatives </span><span class="cov8" title="1">{
                if strings.EqualFold(relative.Person.Name, secondPersonName) </span><span class="cov8" title="1">{
                        logger.Info(fmt.Sprintf("[Service] DetermineRelationship finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))
                        return relative.Type, nil
                }</span>
        }

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] DetermineRelationship finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))

        return "", nil</span>
}

func (s *Service) CalculateKinshipDistance(ctx context.Context, firstPersonName, secondPersonName string) (int, error) <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] CalculateKinshipDistance started for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))
        firstPerson, err := s.PersonRepo.GetByName(ctx, firstPersonName)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] CalculateKinshipDistance error for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName), err)
                return 0, fmt.Errorf("get person error: %w", err)
        }</span>
        <span class="cov8" title="1">persons, err := s.PersonRepo.ListWithRelationships(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] CalculateKinshipDistance error for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName), err)
                return 0, fmt.Errorf("get person error: %w", err)
        }</span>

        <span class="cov8" title="1">relatives := s.Genealogy.BuildFamilyTree(ctx, firstPerson, persons, 1)

        if len(relatives) == 0 </span><span class="cov8" title="1">{
                logger.Info(fmt.Sprintf("[Service] CalculateKinshipDistance finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))
                return 0, nil
        }</span>

        <span class="cov8" title="1">for _, relative := range relatives </span><span class="cov8" title="1">{
                if strings.EqualFold(relative.Person.Name, secondPersonName) </span><span class="cov8" title="1">{
                        logger.Info(fmt.Sprintf("[Service] CalculateKinshipDistance finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))
                        return relative.Level, nil
                }</span>
        }

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] CalculateKinshipDistance finished for firstPersonName: %s and secondPersonName: %s", firstPersonName, secondPersonName))

        return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package gin

import (
        "net/http"

        "github.com/GeovaneCavalcante/tree-genealogical/familytree"
        "github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
        "github.com/gin-gonic/gin"
)

// @Summary Find family members
// @Description Find family members
// @Tags familytree
// @Accept json,xml
// @Produce json,xml
// @Param personName path string true "Person Name"
// @Success 200 {object} presenter.FamilyTreeResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 500 {object} errorResponse
// @Router /familytree/members/{personName} [get]
func findFamilyMembersHandler(s familytree.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Find family members started")
                personName := c.Param("personName")

                if IsEmpty(personName) </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Find family members error: personName should not be empty", nil)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": "personName should not be empty"})
                        return
                }</span>

                <span class="cov8" title="1">relatives, err := s.GetAllFamilyMembers(c, personName)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Find family members error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">r := presenter.NewFamilyTreeResponse(relatives)

                logger.Info("[Handler] Find family members finished")

                respondAccept(c, http.StatusOK, r)</span>
        }
}

// @Summary Determine relationship
// @Description Determine relationship
// @Tags familytree
// @Accept json,xml
// @Produce json,xml
// @Param firstPersonName path string true "First Person Name"
// @Param secondPersonName path string true "Second Person Name"
// @Success 200 {object} presenter.DetermineRelationResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 500 {object} errorResponse
// @Router /familytree/relationship/{firstPersonName}/{secondPersonName} [get]
func determineRelationshipHandler(s familytree.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Determine relationship started")
                firstPersonName := c.Param("firstPersonName")
                secondPersonName := c.Param("secondPersonName")

                if firstPersonName == secondPersonName </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine relationship error: firstPersonName and secondPersonName should be different", nil)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": "firstPersonName and secondPersonName should be different"})
                        return
                }</span>

                <span class="cov8" title="1">if IsEmpty(firstPersonName) || IsEmpty(secondPersonName) </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine relationship error: firstPersonName and secondPersonName should not be empty", nil)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": "firstPersonName and secondPersonName should not be empty"})
                        return
                }</span>

                <span class="cov8" title="1">relationship, err := s.DetermineRelationship(c, firstPersonName, secondPersonName)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">determineRelationResponse := presenter.NewDetermineRelationResponse(relationship)

                logger.Info("[Handler] Determine relationship finished")

                respondAccept(c, http.StatusOK, determineRelationResponse)</span>

        }
}

// @Summary Determine kinship distance
// @Description Determine kinship distance
// @Tags familytree
// @Accept json,xml
// @Produce json,xml
// @Param firstPersonName path string true "First Person Name"
// @Param secondPersonName path string true "Second Person Name"
// @Success 200 {object} presenter.KinshipDistanceResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 500 {object} errorResponse
// @Router /familytree/kinship/distance/{firstPersonName}/{secondPersonName} [get]
func determineKinshipHandler(s familytree.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Determine kinship started")
                firstPersonName := c.Param("firstPersonName")
                secondPersonName := c.Param("secondPersonName")

                if firstPersonName == secondPersonName </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine kinship error: firstPersonName and secondPersonName should be different", nil)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": "firstPersonName and secondPersonName should be different"})
                        return
                }</span>

                <span class="cov8" title="1">if IsEmpty(firstPersonName) || IsEmpty(secondPersonName) </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine kinship error: firstPersonName and secondPersonName should not be empty", nil)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": "firstPersonName and secondPersonName should not be empty"})
                        return
                }</span>

                <span class="cov8" title="1">distance, err := s.CalculateKinshipDistance(c, firstPersonName, secondPersonName)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Determine kinship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">kinshipDistanceResponse := presenter.NewKinshipDistanceResponse(distance)

                logger.Info("[Handler] Determine kinship finished")

                respondAccept(c, http.StatusOK, kinshipDistanceResponse)</span>
        }
}

func MakeFamilyTreeHandlers(r *gin.RouterGroup, s familytree.UseCase) <span class="cov8" title="1">{
        r.Handle("GET", "/members/:personName", findFamilyMembersHandler(s))
        r.Handle("GET", "/relationship/:firstPersonName/:secondPersonName", determineRelationshipHandler(s))
        r.Handle("GET", "/kinship/distance/:firstPersonName/:secondPersonName", determineKinshipHandler(s))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package gin

import (
        "fmt"
        "io"
        "net/http"

        "github.com/GeovaneCavalcante/tree-genealogical/config"
        _ "github.com/GeovaneCavalcante/tree-genealogical/docs"
        "github.com/GeovaneCavalcante/tree-genealogical/familytree"
        "github.com/GeovaneCavalcante/tree-genealogical/person"
        "github.com/GeovaneCavalcante/tree-genealogical/relationship"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "gopkg.in/yaml.v2"
)

type errorResponse struct {
        Error string `json:"error" xml:"error"`
}

func Handlers(envs *config.Environments, personService person.UseCase, relationshipServoce relationship.UseCase, familyTreeService familytree.UseCase) *gin.Engine <span class="cov8" title="1">{
        r := gin.Default()

        r.GET("/health", healthHandler)
        v1 := r.Group("/api/v1")

        url := ginSwagger.URL("/swagger/doc.json")
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))
        r.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.DefaultModelsExpandDepth(-1)))

        pG := v1.Group("/person")
        MakePersonHandlers(pG, personService)

        rG := v1.Group("/relationship")
        MakeRelationshipHandlers(rG, relationshipServoce)

        fG := v1.Group("/familytree")
        MakeFamilyTreeHandlers(fG, familyTreeService)

        return r
}</span>

func healthHandler(c *gin.Context) <span class="cov8" title="1">{
        c.String(http.StatusOK, "App is healthy")
}</span>

func respondAccept(c *gin.Context, status int, data interface{}) <span class="cov8" title="1">{
        fmt.Println(c.GetHeader("Accept"))
        switch c.GetHeader("Accept") </span>{
        case "text/xml", "application/xml":<span class="cov8" title="1">
                c.XML(status, data)
                return</span>
        case "application/json":<span class="cov8" title="1">
                c.JSON(status, data)
                return</span>
        case "application/x-yaml", "text/yaml", "text/x-yaml", "application/yaml":<span class="cov8" title="1">
                yamlData, err := yaml.Marshal(data)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal Server Error"})
                        return
                }</span>
                <span class="cov8" title="1">c.Data(status, "application/x-yaml", yamlData)
                return</span>
        default:<span class="cov8" title="1">
                c.JSON(status, data)
                return</span>
        }
}

func bindData(c *gin.Context, obj interface{}) error <span class="cov8" title="1">{
        switch c.GetHeader("Content-Type") </span>{
        case "application/xml", "text/xml", "application/json":<span class="cov8" title="1">
                if err := c.ShouldBind(obj); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case "application/x-yaml", "text/yaml", "text/x-yaml", "application/yaml":<span class="cov8" title="1">
                body, err := io.ReadAll(c.Request.Body)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := yaml.Unmarshal(body, obj); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        default:<span class="cov8" title="1">
                if err := c.BindJSON(obj); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func IsEmpty(value string) bool <span class="cov8" title="1">{
        return value == "" || value == " "
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package gin

import (
        "fmt"
        "net/http"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter"
        "github.com/GeovaneCavalcante/tree-genealogical/person"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
        "github.com/gin-gonic/gin"
)

// @Summary Create a person
// @Description Create a person
// @Tags person
// @Accept json,xml
// @Produce json,xml
// @Param person body presenter.PersonRequest true "Person"
// @Success 201 {object} presenter.PersonResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 500 {object} errorResponse
// @Router /person [post]
func createPersonHandler(s person.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Create person started")
                var p presenter.PersonRequest
                if err := bindData(c, &amp;p); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create person error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">fmt.Println(p)

                if err := p.Validate(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create person error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">pp := p.ToPerson()

                if err := s.Create(c, pp); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create person error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">person := presenter.NewPersonResponse(pp)

                logger.Info("[Handler] Create person finished")
                respondAccept(c, http.StatusCreated, person)</span>
        }
}

// @Summary List persons
// @Description List persons
// @Tags person
// @Accept json,xml
// @Produce json,xml
// @Param name query string false "Filter by person's lasted name (no implemeted)"
// @Success 200 {array} presenter.PersonResponse
// @Failure 500 {object} errorResponse
// @Router /person [get]
func listPersonHandler(s person.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] List person started")

                filters := map[string]interface{}{}

                persons, err := s.List(c, filters)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] List person error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if len(persons) == 0 </span><span class="cov8" title="1">{
                        logger.Info("[Handler] List person not found")
                        respondAccept(c, http.StatusOK, []entity.Person{})
                        return
                }</span>

                <span class="cov8" title="1">pp := presenter.NewPersonsResponse(persons)

                logger.Info("[Handler] List person finished")
                respondAccept(c, http.StatusOK, pp)</span>
        }
}

// @Summary Get a person
// @Description Get a person
// @Tags person
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Person ID"
// @Success 200 {object} presenter.PersonResponse
// @Failure 404 {object} errorResponse "Person not found"
// @Failure 500 {object} errorResponse
// @Router /person/{id} [get]
func getPersonHandler(s person.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Get person started")

                personID := c.Param("id")

                if IsEmpty(personID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Get person not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "person not found"})
                        return
                }</span>

                <span class="cov8" title="1">p, err := s.Get(c, personID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Get person error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Get person not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "person not found"})
                        return
                }</span>

                <span class="cov8" title="1">pp := presenter.NewPersonResponse(p)

                logger.Info("[Handler] Get person finished")
                respondAccept(c, http.StatusOK, pp)</span>
        }
}

// @Summary Update a person
// @Description Update a person
// @Tags person
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Person ID"
// @Param person body presenter.PersonRequest true "Person"
// @Success 200 {object} presenter.PersonResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 404 {object} errorResponse "Person not found"
// @Failure 500 {object} errorResponse
// @Router /person/{id} [put]
func updatePersonHandler(s person.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Update person started")
                personID := c.Param("id")

                if IsEmpty(personID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Update person not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "person not found"})
                        return
                }</span>

                <span class="cov8" title="1">var p presenter.PersonRequest
                if err := bindData(c, &amp;p); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update person error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if err := p.Validate(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update person error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">pp := p.ToPerson()

                if err := s.Update(c, personID, pp); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update person error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">person := presenter.NewPersonResponse(pp)

                logger.Info("[Handler] Update person finished")
                respondAccept(c, http.StatusOK, person)</span>
        }
}

// @Summary Delete a person
// @Description Delete a person
// @Tags person
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Person ID"
// @Success 204
// @Failure 404 {object} errorResponse "Person not found"
// @Failure 500 {object} errorResponse
// @Router /person/{id} [delete]
func deletePersonHandler(s person.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                personID := c.Param("id")

                if IsEmpty(personID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Delete person not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "person not found"})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] Delete person started")

                if err := s.Delete(c, personID); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Delete person error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] Delete person finished")
                respondAccept(c, http.StatusNoContent, nil)</span>
        }
}

func MakePersonHandlers(r *gin.RouterGroup, s person.UseCase) <span class="cov8" title="1">{
        r.Handle("POST", "/", createPersonHandler(s))
        r.Handle("GET", "/", listPersonHandler(s))
        r.Handle("GET", "/:id", getPersonHandler(s))
        r.Handle("PUT", "/:id", updatePersonHandler(s))
        r.Handle("DELETE", "/:id", deletePersonHandler(s))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package gin

import (
        "net/http"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/http/presenter"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
        "github.com/GeovaneCavalcante/tree-genealogical/relationship"
        "github.com/gin-gonic/gin"
)

// @Summary Create a relationship
// @Description Create a relationship
// @Tags relationship
// @Accept json,xml
// @Produce json,xml
// @Param relationship body presenter.PaternityRelationshipRequest true "Relationship"
// @Success 201 {object} presenter.PaternityRelationshipResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 500 {object} errorResponse
// @Router /relationship [post]
func createRelationshipHandler(s relationship.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Create relationship started")
                var r presenter.PaternityRelationshipRequest
                if err := bindData(c, &amp;r); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create relationship error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if err := r.Validate(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create relationship error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">rs := r.ToRelationship()

                if err := s.Create(c, rs); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Create relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">rp := presenter.NewPaternityRelationshipResponse(rs)

                logger.Info("[Handler] Create relationship finished")

                respondAccept(c, http.StatusCreated, rp)</span>
        }
}

// @Summary List relationships
// @Description List relationships
// @Tags relationship
// @Accept json,xml
// @Produce json,xml
// @Success 200 {array} presenter.PaternityRelationshipResponse
// @Failure 500 {object} errorResponse
// @Router /relationship [get]
func listRelationshipHandler(s relationship.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] List relationship started")
                filters := map[string]interface{}{}

                relationships, err := s.List(c, filters)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] List relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if len(relationships) == 0 </span><span class="cov8" title="1">{
                        logger.Info("[Handler] List relationship not found")
                        respondAccept(c, http.StatusOK, []presenter.PaternityRelationshipResponse{})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] List relationship finished")

                rP := presenter.NewPaternityRelationshipsResponse(relationships)

                respondAccept(c, http.StatusOK, rP)</span>
        }
}

// @Summary Get a relationship
// @Description Get a relationship
// @Tags relationship
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Relationship ID"
// @Success 200 {object} presenter.PaternityRelationshipResponse
// @Failure 404 {object} errorResponse "Relationship not found"
// @Failure 500 {object} errorResponse
// @Router /relationship/{id} [get]
func getRelationshipHandler(s relationship.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Get relationship started")
                relationshipID := c.Param("id")

                if IsEmpty(relationshipID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Get relationship not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "relationship not found"})
                        return
                }</span>

                <span class="cov8" title="1">r, err := s.Get(c, relationshipID)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Get relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if r == nil </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Get relationship not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "relationship not found"})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] Get relationship finished")

                rp := presenter.NewPaternityRelationshipResponse(r)

                respondAccept(c, http.StatusOK, rp)</span>
        }
}

// @Summary Update a relationship
// @Description Update a relationship
// @Tags relationship
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Relationship ID"
// @Param relationship body presenter.PaternityRelationshipRequest true "Relationship"
// @Success 200 {object} presenter.PaternityRelationshipResponse
// @Failure 400 {object} errorResponse "Bad Request"
// @Failure 404 {object} errorResponse "Relationship not found"
// @Failure 500 {object} errorResponse
// @Router /relationship/{id} [put]
func updateRelationshipHandler(s relationship.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Update relationship started")
                relationshipID := c.Param("id")

                if IsEmpty(relationshipID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Update relationship not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "relationship not found"})
                        return
                }</span>

                <span class="cov8" title="1">var r presenter.PaternityRelationshipRequest
                if err := bindData(c, &amp;r); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update relationship error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if err := r.Validate(); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update relationship error: ", err)
                        respondAccept(c, http.StatusBadRequest, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">rs := r.ToRelationship()

                if err := s.Update(c, relationshipID, rs); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Update relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] Update relationship finished")

                rp := presenter.NewPaternityRelationshipResponse(rs)

                respondAccept(c, http.StatusOK, rp)</span>
        }
}

// @Summary Delete a relationship
// @Description Delete a relationship
// @Tags relationship
// @Accept json,xml
// @Produce json,xml
// @Param id path string true "Relationship ID"
// @Success 204
// @Failure 404 {object} errorResponse "Relationship not found"
// @Failure 500 {object} errorResponse
// @Router /relationship/{id} [delete]
func deleteRelationshipHandler(s relationship.UseCase) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                logger.Info("[Handler] Delete relationship started")
                relationshipID := c.Param("id")

                if IsEmpty(relationshipID) </span><span class="cov8" title="1">{
                        logger.Info("[Handler] Delete relationship not found")
                        respondAccept(c, http.StatusNotFound, gin.H{"error": "relationship not found"})
                        return
                }</span>

                <span class="cov8" title="1">if err := s.Delete(c, relationshipID); err != nil </span><span class="cov8" title="1">{
                        logger.Error("[Handler] Delete relationship error: ", err)
                        respondAccept(c, http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">logger.Info("[Handler] Delete relationship finished")
                respondAccept(c, http.StatusNoContent, nil)</span>
        }
}

func MakeRelationshipHandlers(r *gin.RouterGroup, s relationship.UseCase) <span class="cov8" title="1">{
        r.POST("", createRelationshipHandler(s))
        r.GET("", listRelationshipHandler(s))
        r.GET("/:id", getRelationshipHandler(s))
        r.PUT("/:id", updateRelationshipHandler(s))
        r.DELETE("/:id", deleteRelationshipHandler(s))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package presenter

import "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"

type FamilyTreeResponse struct {
        Members []*Member `json:"members" xml:"members"`
}

type DetermineRelationResponse struct {
        Relationship string `json:"relationship" xml:"relationship"`
}

type KinshipDistanceResponse struct {
        Distance int `json:"distance" xml:"distance"`
}

type Member struct {
        Name             string          `json:"name" xml:"name"`
        TypeRelationship string          `json:"typeRelationship" xml:"typeRelationship"`
        Relationships    []*Relationship `json:"relationships" xml:"relationships"`
}

type Relationship struct {
        Name string `json:"parent" xml:"parent"`
}

func NewKinshipDistanceResponse(distance int) *KinshipDistanceResponse <span class="cov8" title="1">{
        return &amp;KinshipDistanceResponse{
                Distance: distance,
        }
}</span>

func NewDetermineRelationResponse(relationship string) *DetermineRelationResponse <span class="cov8" title="1">{
        return &amp;DetermineRelationResponse{
                Relationship: relationship,
        }
}</span>

func NewFamilyTreeResponse(relatives []*entity.Relative) *FamilyTreeResponse <span class="cov8" title="1">{
        members := make([]*Member, 0, len(relatives))

        for _, relative := range relatives </span><span class="cov8" title="1">{
                if relative.Person == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">member := &amp;Member{
                        Name:             relative.Person.Name,
                        TypeRelationship: relative.Type,
                        Relationships:    make([]*Relationship, 0, len(relative.Person.Relationships)),
                }

                for _, rel := range relative.Person.Relationships </span><span class="cov8" title="1">{
                        if rel.SecundePerson == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">member.Relationships = append(member.Relationships, &amp;Relationship{
                                Name: rel.SecundePerson.Name,
                        })</span>
                }

                <span class="cov8" title="1">members = append(members, member)</span>
        }

        <span class="cov8" title="1">return &amp;FamilyTreeResponse{
                Members: members,
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package presenter

import (
        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/go-playground/validator/v10"
)

type PersonResponse struct {
        ID     string `json:"id" xml:"id"`
        Name   string `json:"name" xml:"name"`
        Gender string `json:"gender" xml:"gender"`
}

type PersonRequest struct {
        Name   string `json:"name" xml:"name" validate:"required"`
        Gender string `json:"gender" xml:"gender" validate:"required,oneof=F M"`
}

func NewPersonResponse(person *entity.Person) *PersonResponse <span class="cov8" title="1">{
        return &amp;PersonResponse{
                ID:     person.ID,
                Name:   person.Name,
                Gender: person.Gender,
        }
}</span>

func NewPersonsResponse(persons []*entity.Person) []*PersonResponse <span class="cov8" title="1">{
        var response []*PersonResponse
        for _, p := range persons </span><span class="cov8" title="1">{
                response = append(response, NewPersonResponse(p))
        }</span>
        <span class="cov8" title="1">return response</span>
}

func NewPersonRequest(person *entity.Person) *PersonRequest <span class="cov8" title="1">{
        return &amp;PersonRequest{
                Name:   person.Name,
                Gender: person.Gender,
        }
}</span>

func (p *PersonRequest) ToPerson() *entity.Person <span class="cov8" title="1">{
        return &amp;entity.Person{
                Name:   p.Name,
                Gender: p.Gender,
        }
}</span>

func (p *PersonRequest) Validate() error <span class="cov8" title="1">{
        validate := validator.New(validator.WithRequiredStructEnabled())
        return validate.Struct(p)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package presenter

import (
        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/go-playground/validator/v10"
)

type PaternityRelationshipResponse struct {
        ID     string `json:"id" xml:"id"`
        Parent string `json:"parent" xml:"parent"`
        Child  string `json:"child" xml:"child"`
}

type PaternityRelationshipRequest struct {
        Parent string `json:"parent" xml:"parent" validate:"required"`
        Child  string `json:"child" xml:"child" validate:"required"`
}

func NewPaternityRelationshipResponse(relationship *entity.Relationship) *PaternityRelationshipResponse <span class="cov8" title="1">{
        return &amp;PaternityRelationshipResponse{
                ID:     relationship.ID,
                Parent: relationship.SecundePersonID,
                Child:  relationship.MainPersonID,
        }
}</span>

func NewPaternityRelationshipsResponse(relationships []*entity.Relationship) []*PaternityRelationshipResponse <span class="cov8" title="1">{
        var response []*PaternityRelationshipResponse
        for _, r := range relationships </span><span class="cov8" title="1">{
                response = append(response, NewPaternityRelationshipResponse(r))
        }</span>
        <span class="cov8" title="1">return response</span>
}

func (p *PaternityRelationshipRequest) NewPaternityRelationshipRequest() *entity.Relationship <span class="cov8" title="1">{
        return &amp;entity.Relationship{
                MainPersonID:    p.Child,
                SecundePersonID: p.Parent,
        }
}</span>

func (p *PaternityRelationshipRequest) ToRelationship() *entity.Relationship <span class="cov8" title="1">{
        return &amp;entity.Relationship{
                MainPersonID:    p.Child,
                SecundePersonID: p.Parent,
        }
}</span>

func (p *PaternityRelationshipRequest) Validate() error <span class="cov8" title="1">{
        validate := validator.New(validator.WithRequiredStructEnabled())
        return validate.Struct(p)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package person

import (
        "context"
        "fmt"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
        }
}</span>

func (s *Service) Create(ctx context.Context, person *entity.Person) error <span class="cov8" title="1">{
        logger.Info("[Service] Create person started")

        err := s.repo.Create(ctx, person)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("[Service] Create person error: ", err)
                return fmt.Errorf("create person error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("[Service] Create person finished")
        return nil</span>
}

func (s *Service) Get(ctx context.Context, personID string) (*entity.Person, error) <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Get person by personID: %s", personID))

        person, err := s.repo.Get(ctx, personID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Get person by personID: %s error ", personID), err)
                return nil, fmt.Errorf("get person error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Get person service finished for personID: %s", personID))
        return person, nil</span>
}

func (s *Service) List(ctx context.Context, filters map[string]interface{}) ([]*entity.Person, error) <span class="cov8" title="1">{
        logger.Info("[Service] List person started")

        persons, err := s.repo.List(ctx, filters)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("[Service] List person error: ", err)
                return nil, fmt.Errorf("list person error: %w", err)
        }</span>

        <span class="cov8" title="1">if len(persons) == 0 </span><span class="cov8" title="1">{
                logger.Info("[Service] List person not found")
                return nil, nil
        }</span>

        <span class="cov8" title="1">logger.Info("[Service] List person finished")
        return persons, nil</span>
}

func (s *Service) Update(ctx context.Context, personID string, person *entity.Person) error <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Update person started by personID: %s", personID))

        p, err := s.Get(ctx, personID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Update person by personID: %s error", personID), err)
                return fmt.Errorf("update person error: %w", err)
        }</span>

        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Update person by personID: %s not found", personID), nil)
                return fmt.Errorf("update person error: not found")
        }</span>

        <span class="cov8" title="1">err = s.repo.Update(ctx, personID, person)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("[Service] Update person error: ", err)
                return fmt.Errorf("update person error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Update person finished by personID: %s", personID))
        return nil</span>
}

func (s *Service) Delete(ctx context.Context, personID string) error <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Delete person started by personID: %s", personID))

        p, err := s.Get(ctx, personID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete person by personID: %s error", personID), err)
                return fmt.Errorf("delete person error: %w", err)
        }</span>

        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete person by personID: %s not found", personID), nil)
                return fmt.Errorf("delete person error: not found")
        }</span>

        <span class="cov8" title="1">err = s.repo.Delete(ctx, personID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete person error by personID: %s", personID), err)
                return fmt.Errorf("delete person error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Delete person finished by personID: %s", personID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package genealogy

import (
        "context"
        "fmt"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
)

const (
        father                string = "Father"
        son                   string = "Son"
        brother               string = "Brother"
        grandFather           string = "GrandFather"
        greatUncle            string = "GreatUncle"
        greatGrandfather      string = "GreatGrandFather"
        greatGreatGrandfather string = "GreatGreatGrandFather"
        uncle                 string = "Uncle"
        cousin                string = "Cousin"
        nephew                string = "Nephew"
        grandSon              string = "GrandSon"
        greatGrandSon         string = "GreatGrandSon"
        unknownRelation       string = "Unknown Relation"
)

var kinshipTypes = map[string]map[string]string{
        father:                {"F": "Mother", "M": "Father"},
        son:                   {"F": "Daughter", "M": "Son"},
        brother:               {"F": "Sister", "M": "Brother"},
        grandFather:           {"F": "GrandMother", "M": "GrandFather"},
        greatUncle:            {"F": "GreatAunt", "M": "GreatUncle"},
        greatGrandfather:      {"F": "GreatGrandMother", "M": "GreatGrandFather"},
        greatGreatGrandfather: {"F": "GreatGreatGrandMother", "M": "GreatGreatGrandFather"},
        uncle:                 {"F": "Aunt", "M": "Uncle"},
        cousin:                {"F": "Cousin", "M": "Cousin"},
        nephew:                {"F": "Niece", "M": "Nephew"},
        grandSon:              {"F": "Granddaughter", "M": "GrandSon"},
        greatGrandSon:         {"F": "GreatGranddaughter", "M": "GreatGrandson"},
}

// Regras para determinar o novo parente com base no parente encontrado.
var rulesChild = map[string]string{
        grandFather:      uncle,
        uncle:            cousin,
        cousin:           nephew,
        brother:          nephew,
        greatGrandfather: greatUncle,
        nephew:           nephew,
        son:              grandSon,
        grandSon:         greatGrandSon,
}

// Regras para determinar o novo parente com base no parente encontrado.
var rulesParents = map[string]string{
        father:      grandFather,
        grandFather: greatGrandfather,
}

type TreeGenealogical struct {
        Root      *entity.Person
        Relatives []*entity.Relative
}

// Cria uma nova árvore genealógica com base no parente e na lista de pessoas.
func NewFamilyTree() *TreeGenealogical <span class="cov8" title="1">{
        tg := &amp;TreeGenealogical{}
        return tg
}</span>

// Constrói a árvore genealógica com base no parente e na lista de pessoas.
func (tg *TreeGenealogical) BuildFamilyTree(ctx context.Context, rootPerson *entity.Person, persons []*entity.Person, level int) []*entity.Relative <span class="cov8" title="1">{

        relatives := []*entity.Relative{
                {
                        Type:   "Root",
                        Level:  level,
                        Person: rootPerson,
                },
        }

        tg.Root = rootPerson
        // Busca por descendentes.
        relatives = tg.searchDescendants(ctx, tg.Root, persons, level, relatives)
        // Busca por ancestrais e seus parentes.
        relatives = tg.searchAncestors(ctx, tg.Root, persons, level, relatives)

        tg.Relatives = relatives
        return relatives
}</span>

// Retorn a arvore genealógica
func (tg *TreeGenealogical) GetRelatives(ctx context.Context) []*entity.Relative <span class="cov8" title="1">{
        return tg.Relatives
}</span>

// Descrição da relação com base no parente e no sexo.
func (tg *TreeGenealogical) relationshipDescription(relative *entity.Person, relatives []*entity.Relative, persons []*entity.Person) string <span class="cov8" title="1">{

        // Verifica se a relação é direta.
        description := tg.directRelationDescription(relative, persons)
        if description != "" </span><span class="cov8" title="1">{
                return description
        }</span>

        // Busca os pais da pessoa com base nos parentes ja catalogados.
        <span class="cov8" title="1">parent := tg.findParents(relative, relatives)

        // Aplica as regras para determinar o novo parente.
        if parent != nil </span><span class="cov8" title="1">{
                for key, value := range rulesParents </span><span class="cov8" title="1">{
                        if isTypeOfTypeKinship(parent.Type, key) </span><span class="cov8" title="1">{
                                return descriptionBySex(value, relative.Gender)
                        }</span>
                }
        }

        // Busca os filhos da pessoa com base nos parentes ja catalogados.
        <span class="cov8" title="1">child := tg.findChildren(relative, relatives)

        // Regras para determinar o novo parente com base no parente encontrado.

        // Aplica as regras para determinar o novo parente.
        if child != nil </span><span class="cov8" title="1">{
                for key, value := range rulesChild </span><span class="cov8" title="1">{
                        if child != nil &amp;&amp; isTypeOfTypeKinship(child.Type, key) </span><span class="cov8" title="1">{
                                return descriptionBySex(value, relative.Gender)
                        }</span>
                }
        }

        <span class="cov8" title="1">return unknownRelation</span>
}

// Busca por ancestrais de maneira recursiva.
func (tg *TreeGenealogical) searchAncestors(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                secundePerson := findPerson(relationship.SecundePersonID, persons)
                if secundePerson == nil || tg.alreadyInFamily(secundePerson, relatives) </span><span class="cov8" title="1">{
                        continue</span> // Pula para o próximo relacionamento se o parente já estiver na lista ou não for encontrado
                }
                // Adiciona o parente encontrado (ancestral) apenas se não estiver já na lista
                <span class="cov8" title="1">re := tg.newRelative(secundePerson, level, relatives, persons)
                relatives = append(relatives, re)

                // Recursivamente busca por mais ancestrais deste parente encontrado
                relatives = tg.searchForRelatives(ctx, secundePerson, persons, level+1, relatives)
                // Recursivamente busca por mais ancestrais
                relatives = tg.searchAncestors(ctx, secundePerson, persons, level+1, relatives)</span>

        }

        <span class="cov8" title="1">return relatives</span>

}

// Busca por descendentes de maneira recursiva.
func (tg *TreeGenealogical) searchDescendants(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, person := range persons </span><span class="cov8" title="1">{
                for _, relationship := range person.Relationships </span><span class="cov8" title="1">{
                        if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                                // Verifica se a pessoa já foi adicionada e não é o Root
                                if !tg.alreadyInFamily(person, relatives) </span><span class="cov8" title="1">{
                                        re := tg.newRelative(person, level, relatives, persons) // Assumindo que newRelative agora aceita relatives
                                        relatives = append(relatives, re)                       // Adiciona o parente apenas uma vez
                                }</span>
                                // Continua a busca por descendentes de maneira recursiva
                                <span class="cov8" title="1">relatives = tg.searchDescendants(ctx, person, persons, level+1, relatives)</span>
                        }
                }
        }
        <span class="cov8" title="1">return relatives</span>
}

// Busca por parentes de maneira recursiva.
func (tg *TreeGenealogical) searchForRelatives(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, person := range persons </span><span class="cov8" title="1">{
                for _, relationship := range person.Relationships </span><span class="cov8" title="1">{
                        if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                                // Verifica se a pessoa já foi adicionada e não é o Root
                                if !tg.alreadyInFamily(person, relatives) &amp;&amp; tg.Root.ID != person.ID </span><span class="cov8" title="1">{
                                        // Se não estiver na lista, adicione e continue a busca recursiva
                                        re := tg.newRelative(person, level, relatives, persons)
                                        relatives = append(relatives, re) // Adiciona uma única vez

                                        // Continua a busca por mais parentes sem passar o mesmo slice modificado
                                        relatives = tg.searchForRelatives(ctx, person, persons, level+1, relatives)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return relatives</span>
}

// Encontra o pais do relative (Parente interado no momento).
func (tg *TreeGenealogical) findParents(relative *entity.Person, relatives []*entity.Relative) *entity.Relative <span class="cov8" title="1">{
        fmt.Println("findParents")
        if relative == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, p := range relatives </span><span class="cov8" title="1">{
                if p.Person == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, relationship := range p.Person.Relationships </span><span class="cov8" title="1">{
                        if relative.ID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (tg *TreeGenealogical) directRelationDescription(relative *entity.Person, persons []*entity.Person) string <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        // Verifica se o relative é filho do Root.
        <span class="cov8" title="1">if tg.isChildOfRoot(relative) </span><span class="cov8" title="1">{
                return descriptionBySex(son, relative.Gender)
        }</span>

        // Verifica se o relative é pai ou mae do Root.
        <span class="cov8" title="1">if tg.isParentOfRoot(relative) </span><span class="cov8" title="1">{
                return descriptionBySex(father, relative.Gender)
        }</span>

        // Verifica se o relative é irmão do Root.
        <span class="cov8" title="1">return tg.checkSiblingRelation(relative, persons)</span>
}

// Verifica se a pessoa é filho(a) do Root.
func (tg *TreeGenealogical) isChildOfRoot(relative *entity.Person) bool <span class="cov8" title="1">{
        for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                if relationship.SecundePersonID == tg.Root.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Verifica se a pessoa é pai/mãe do Root.
func (tg *TreeGenealogical) isParentOfRoot(relative *entity.Person) bool <span class="cov8" title="1">{
        for _, relationship := range tg.Root.Relationships </span><span class="cov8" title="1">{
                if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Verifica se a pessoa é irmão do Root.
func (tg *TreeGenealogical) checkSiblingRelation(relative *entity.Person, persons []*entity.Person) string <span class="cov8" title="1">{
        for _, relationship := range tg.Root.Relationships </span><span class="cov8" title="1">{
                for _, relationshipParent := range relative.Relationships </span><span class="cov8" title="1">{
                        if relationshipParent.SecundePersonID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return descriptionBySex(brother, relative.Gender)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

// Encontra o parente que é filho do relative (Parente interado no momento).
func (tg *TreeGenealogical) findChildren(relative *entity.Person, relatives []*entity.Relative) *entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, p := range relatives </span><span class="cov8" title="1">{
                for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                        if p.Person == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Person.ID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Cria um novo parente com base no relative e o adiciona à lista de parentes.
func (tg *TreeGenealogical) newRelative(person *entity.Person, level int, relatives []*entity.Relative, persons []*entity.Person) *entity.Relative <span class="cov8" title="1">{
        relative := &amp;entity.Relative{
                Type:   tg.relationshipDescription(person, relatives, persons),
                Level:  level,
                Person: person,
        }
        return relative
}</span>

// Verifica se o parente já está na lista de parentes.
func (tg *TreeGenealogical) alreadyInFamily(relative *entity.Person, relatives []*entity.Relative) bool <span class="cov8" title="1">{
        for _, p := range relatives </span><span class="cov8" title="1">{
                if p.Person == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if p.Person.ID == relative.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Retorna a descrição da relação com base no parente e no sexo.
func descriptionBySex(relative, gender string) string <span class="cov8" title="1">{
        if relation, ok := kinshipTypes[relative]; ok </span><span class="cov8" title="1">{
                if desc, ok := relation[gender]; ok </span><span class="cov8" title="1">{
                        return desc
                }</span>
                <span class="cov8" title="1">return unknownRelation</span>
        }
        <span class="cov8" title="1">return unknownRelation</span>
}

// Verifica se o tipo de parentesco é válido.
func isTypeOfTypeKinship(typeKinship, p string) bool <span class="cov8" title="1">{
        if _, ok := kinshipTypes[p]; !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, value := range kinshipTypes[p] </span><span class="cov8" title="1">{
                if typeKinship == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Encontra a pessoa com base no ID.
func findPerson(ID string, persons []*entity.Person) *entity.Person <span class="cov8" title="1">{
        for _, person := range persons </span><span class="cov8" title="1">{
                if person.ID == ID </span><span class="cov8" title="1">{
                        return person
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package relationship

import (
        "context"
        "fmt"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
        "github.com/GeovaneCavalcante/tree-genealogical/pkg/logger"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
        }
}</span>

func (s *Service) Create(ctx context.Context, relationship *entity.Relationship) error <span class="cov8" title="1">{
        logger.Info("[Service] Create relationship started")

        err := s.repo.Create(ctx, relationship)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("[Service] Create relationship error: ", err)
                return fmt.Errorf("create relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("[Service] Create relationship finished")
        return nil</span>
}

func (s *Service) Get(ctx context.Context, relationshipID string) (*entity.Relationship, error) <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Get relationship by relationshipID: %s", relationshipID))

        relationship, err := s.repo.Get(ctx, relationshipID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Get relationship by relationshipID: %s error ", relationshipID), err)
                return nil, fmt.Errorf("get relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Get relationship service finished for relationshipID: %s", relationshipID))
        return relationship, nil</span>
}

func (s *Service) List(ctx context.Context, filters map[string]interface{}) ([]*entity.Relationship, error) <span class="cov8" title="1">{
        logger.Info("[Service] List relationship started")

        relationships, err := s.repo.List(ctx, filters)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("[Service] List relationship error: ", err)
                return nil, fmt.Errorf("list relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("[Service] List relationship finished")
        return relationships, nil</span>
}

func (s *Service) Update(ctx context.Context, relationshipID string, relationship *entity.Relationship) error <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Update relationship started by relationshipID: %s", relationshipID))

        r, err := s.Get(ctx, relationshipID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Update relationship by relationshipID: %s error ", relationshipID), err)
                return fmt.Errorf("update relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">if r == nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Update relationship by relationshipID %s error not found ", relationshipID), nil)
                return fmt.Errorf("relationship not found")
        }</span>

        <span class="cov8" title="1">err = s.repo.Update(ctx, relationshipID, relationship)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Update relationship by relationshipID: %s error ", relationshipID), err)
                return fmt.Errorf("update relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Update relationship service finished for relationshipID: %s", relationshipID))
        return nil</span>
}

func (s *Service) Delete(ctx context.Context, relationshipID string) error <span class="cov8" title="1">{
        logger.Info(fmt.Sprintf("[Service] Delete relationship started by relationshipID: %s", relationshipID))

        r, err := s.Get(ctx, relationshipID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete relationship by relationshipID: %s error ", relationshipID), err)
                return fmt.Errorf("delete relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">if r == nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete relationship by relationshipID %s error not found ", relationshipID), nil)
                return fmt.Errorf("relationship not found")
        }</span>

        <span class="cov8" title="1">err = s.repo.Delete(ctx, relationshipID)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(fmt.Sprintf("[Service] Delete relationship by relationshipID: %s error ", relationshipID), err)
                return fmt.Errorf("delete relationship error: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info(fmt.Sprintf("[Service] Delete relationship service finished for relationshipID: %s", relationshipID))
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
