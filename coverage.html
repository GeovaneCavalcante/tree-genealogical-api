
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>genealogy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/GeovaneCavalcante/tree-genealogical/pkg/genealogy/genealogy.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package genealogy

import (
        "context"
        "fmt"

        "github.com/GeovaneCavalcante/tree-genealogical/internal/entity"
)

const (
        father                string = "Father"
        son                   string = "Son"
        brother               string = "Brother"
        grandFather           string = "GrandFather"
        greatUncle            string = "GreatUncle"
        greatGrandfather      string = "GreatGrandFather"
        greatGreatGrandfather string = "GreatGreatGrandFather"
        uncle                 string = "Uncle"
        cousin                string = "Cousin"
        nephew                string = "Nephew"
        grandSon              string = "GrandSon"
        greatGrandSon         string = "GreatGrandSon"
        unknownRelation       string = "Unknown Relation"
)

var kinshipTypes = map[string]map[string]string{
        father:                {"F": "Mother", "M": "Father"},
        son:                   {"F": "Daughter", "M": "Son"},
        brother:               {"F": "Sister", "M": "Brother"},
        grandFather:           {"F": "GrandMother", "M": "GrandFather"},
        greatUncle:            {"F": "GreatAunt", "M": "GreatUncle"},
        greatGrandfather:      {"F": "GreatGrandMother", "M": "GreatGrandFather"},
        greatGreatGrandfather: {"F": "GreatGreatGrandMother", "M": "GreatGreatGrandFather"},
        uncle:                 {"F": "Aunt", "M": "Uncle"},
        cousin:                {"F": "Cousin", "M": "Cousin"},
        nephew:                {"F": "Niece", "M": "Nephew"},
        grandSon:              {"F": "Granddaughter", "M": "GrandSon"},
        greatGrandSon:         {"F": "GreatGranddaughter", "M": "GreatGrandson"},
}

type TreeGenealogical struct {
        Root      *entity.Person
        Relatives []*entity.Relative
}

// Cria uma nova árvore genealógica com base no parente e na lista de pessoas.
func NewFamilyTree() *TreeGenealogical <span class="cov8" title="1">{
        tg := &amp;TreeGenealogical{}
        return tg
}</span>

// Constrói a árvore genealógica com base no parente e na lista de pessoas.
func (tg *TreeGenealogical) BuildFamilyTree(ctx context.Context, rootPerson *entity.Person, persons []*entity.Person, level int) []*entity.Relative <span class="cov8" title="1">{

        relatives := []*entity.Relative{
                {
                        Type:   "Root",
                        Level:  level,
                        Person: rootPerson,
                },
        }

        tg.Root = rootPerson
        // Busca por descendentes.
        relatives = tg.searchDescendants(ctx, tg.Root, persons, level, relatives)
        // Busca por ancestrais e seus parentes.
        relatives = tg.searchAncestors(ctx, tg.Root, persons, level, relatives)

        tg.Relatives = relatives
        return relatives
}</span>

// Retorn a arvore genealógica
func (tg *TreeGenealogical) GetRelatives(ctx context.Context) []*entity.Relative <span class="cov8" title="1">{
        return tg.Relatives
}</span>

// Descrição da relação com base no parente e no sexo.
func (tg *TreeGenealogical) relationshipDescription(relative *entity.Person, relatives []*entity.Relative, persons []*entity.Person) string <span class="cov8" title="1">{

        // Verifica se a relação é direta.
        description := tg.directRelationDescription(relative, persons)
        if description != "" </span><span class="cov8" title="1">{
                return description
        }</span>

        // Busca os pais da pessoa com base nos parentes ja catalogados.
        <span class="cov8" title="1">parent := tg.findParents(relative, relatives)

        // Regras para determinar o novo parente com base no parente encontrado.
        rulesParents := map[string]string{
                father:      grandFather,
                grandFather: greatGrandfather,
        }

        // Aplica as regras para determinar o novo parente.
        if parent != nil </span><span class="cov8" title="1">{
                for key, value := range rulesParents </span><span class="cov8" title="1">{
                        if isTypeOfTypeKinship(parent.Type, key) </span><span class="cov8" title="1">{
                                return descriptionBySex(value, relative.Gender)
                        }</span>
                }
        }

        // Busca os filhos da pessoa com base nos parentes ja catalogados.
        <span class="cov8" title="1">child := tg.findChildren(relative, relatives)

        // Regras para determinar o novo parente com base no parente encontrado.
        rulesChild := map[string]string{
                grandFather:      uncle,
                uncle:            cousin,
                cousin:           nephew,
                brother:          nephew,
                greatGrandfather: greatUncle,
                nephew:           nephew,
                son:              grandSon,
                grandSon:         greatGrandSon,
        }

        // Aplica as regras para determinar o novo parente.
        if child != nil </span><span class="cov8" title="1">{
                for key, value := range rulesChild </span><span class="cov8" title="1">{
                        if child != nil &amp;&amp; isTypeOfTypeKinship(child.Type, key) </span><span class="cov8" title="1">{
                                return descriptionBySex(value, relative.Gender)
                        }</span>
                }
        }

        <span class="cov8" title="1">return unknownRelation</span>
}

// Busca por ancestrais de maneira recursiva.
func (tg *TreeGenealogical) searchAncestors(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                secundePerson := findPerson(relationship.SecundePersonID, persons)
                if secundePerson == nil || tg.alreadyInFamily(secundePerson, relatives) </span><span class="cov8" title="1">{
                        continue</span> // Pula para o próximo relacionamento se o parente já estiver na lista ou não for encontrado
                }
                // Adiciona o parente encontrado (ancestral) apenas se não estiver já na lista
                <span class="cov8" title="1">re := tg.newRelative(secundePerson, level, relatives, persons)
                relatives = append(relatives, re)

                // Recursivamente busca por mais ancestrais deste parente encontrado
                relatives = tg.searchForRelatives(ctx, secundePerson, persons, level+1, relatives)
                // Recursivamente busca por mais ancestrais
                relatives = tg.searchAncestors(ctx, secundePerson, persons, level+1, relatives)</span>

        }

        <span class="cov8" title="1">return relatives</span>

}

// Busca por descendentes de maneira recursiva.
func (tg *TreeGenealogical) searchDescendants(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, person := range persons </span><span class="cov8" title="1">{
                for _, relationship := range person.Relationships </span><span class="cov8" title="1">{
                        if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                                // Verifica se a pessoa já foi adicionada e não é o Root
                                if !tg.alreadyInFamily(person, relatives) </span><span class="cov8" title="1">{
                                        re := tg.newRelative(person, level, relatives, persons) // Assumindo que newRelative agora aceita relatives
                                        relatives = append(relatives, re)                       // Adiciona o parente apenas uma vez
                                }</span>
                                // Continua a busca por descendentes de maneira recursiva
                                <span class="cov8" title="1">relatives = tg.searchDescendants(ctx, person, persons, level+1, relatives)</span>
                        }
                }
        }
        <span class="cov8" title="1">return relatives</span>
}

// Busca por parentes de maneira recursiva.
func (tg *TreeGenealogical) searchForRelatives(ctx context.Context, relative *entity.Person, persons []*entity.Person, level int, relatives []*entity.Relative) []*entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return relatives
        }</span>
        <span class="cov8" title="1">for _, person := range persons </span><span class="cov8" title="1">{
                for _, relationship := range person.Relationships </span><span class="cov8" title="1">{
                        if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                                // Verifica se a pessoa já foi adicionada e não é o Root
                                if !tg.alreadyInFamily(person, relatives) &amp;&amp; tg.Root.ID != person.ID </span><span class="cov8" title="1">{
                                        // Se não estiver na lista, adicione e continue a busca recursiva
                                        re := tg.newRelative(person, level, relatives, persons)
                                        relatives = append(relatives, re) // Adiciona uma única vez

                                        // Continua a busca por mais parentes sem passar o mesmo slice modificado
                                        relatives = tg.searchForRelatives(ctx, person, persons, level+1, relatives)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return relatives</span>
}

// Encontra o pais do relative (Parente interado no momento).
func (tg *TreeGenealogical) findParents(relative *entity.Person, relatives []*entity.Relative) *entity.Relative <span class="cov8" title="1">{
        fmt.Println("findParents")
        if relative == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, p := range relatives </span><span class="cov8" title="1">{
                if p.Person == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, relationship := range p.Person.Relationships </span><span class="cov8" title="1">{
                        if relative.ID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (tg *TreeGenealogical) directRelationDescription(relative *entity.Person, persons []*entity.Person) string <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        // Verifica se o relative é filho do Root.
        <span class="cov8" title="1">if tg.isChildOfRoot(relative) </span><span class="cov8" title="1">{
                return descriptionBySex(son, relative.Gender)
        }</span>

        // Verifica se o relative é pai ou mae do Root.
        <span class="cov8" title="1">if tg.isParentOfRoot(relative) </span><span class="cov8" title="1">{
                return descriptionBySex(father, relative.Gender)
        }</span>

        // Verifica se o relative é irmão do Root.
        <span class="cov8" title="1">return tg.checkSiblingRelation(relative, persons)</span>
}

// Verifica se a pessoa é filho(a) do Root.
func (tg *TreeGenealogical) isChildOfRoot(relative *entity.Person) bool <span class="cov8" title="1">{
        for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                if relationship.SecundePersonID == tg.Root.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Verifica se a pessoa é pai/mãe do Root.
func (tg *TreeGenealogical) isParentOfRoot(relative *entity.Person) bool <span class="cov8" title="1">{
        for _, relationship := range tg.Root.Relationships </span><span class="cov8" title="1">{
                if relationship.SecundePersonID == relative.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Verifica se a pessoa é irmão do Root.
func (tg *TreeGenealogical) checkSiblingRelation(relative *entity.Person, persons []*entity.Person) string <span class="cov8" title="1">{
        for _, relationship := range tg.Root.Relationships </span><span class="cov8" title="1">{
                for _, relationshipParent := range relative.Relationships </span><span class="cov8" title="1">{
                        if relationshipParent.SecundePersonID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return descriptionBySex(brother, relative.Gender)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

// Encontra o parente que é filho do relative (Parente interado no momento).
func (tg *TreeGenealogical) findChildren(relative *entity.Person, relatives []*entity.Relative) *entity.Relative <span class="cov8" title="1">{
        if relative == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, p := range relatives </span><span class="cov8" title="1">{
                for _, relationship := range relative.Relationships </span><span class="cov8" title="1">{
                        if p.Person == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Person.ID == relationship.SecundePersonID </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Cria um novo parente com base no relative e o adiciona à lista de parentes.
func (tg *TreeGenealogical) newRelative(person *entity.Person, level int, relatives []*entity.Relative, persons []*entity.Person) *entity.Relative <span class="cov8" title="1">{
        relative := &amp;entity.Relative{
                Type:   tg.relationshipDescription(person, relatives, persons),
                Level:  level,
                Person: person,
        }
        return relative
}</span>

// Verifica se o parente já está na lista de parentes.
func (tg *TreeGenealogical) alreadyInFamily(relative *entity.Person, relatives []*entity.Relative) bool <span class="cov8" title="1">{
        for _, p := range relatives </span><span class="cov8" title="1">{
                if p.Person == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if p.Person.ID == relative.ID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Retorna a descrição da relação com base no parente e no sexo.
func descriptionBySex(relative, gender string) string <span class="cov8" title="1">{
        if relation, ok := kinshipTypes[relative]; ok </span><span class="cov8" title="1">{
                if desc, ok := relation[gender]; ok </span><span class="cov8" title="1">{
                        return desc
                }</span>
                <span class="cov8" title="1">return unknownRelation</span>
        }
        <span class="cov8" title="1">return unknownRelation</span>
}

// Verifica se o tipo de parentesco é válido.
func isTypeOfTypeKinship(typeKinship, p string) bool <span class="cov8" title="1">{
        if _, ok := kinshipTypes[p]; !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, value := range kinshipTypes[p] </span><span class="cov8" title="1">{
                if typeKinship == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Encontra a pessoa com base no ID.
func findPerson(ID string, persons []*entity.Person) *entity.Person <span class="cov8" title="1">{
        for _, person := range persons </span><span class="cov8" title="1">{
                if person.ID == ID </span><span class="cov8" title="1">{
                        return person
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
